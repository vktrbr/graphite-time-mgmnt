# Дизайн ML-системы: Предсказание времени выполнения задач

## 1. Цели и предпосылки

### 1.1 Обоснование разработки продукта

- **Бизнес-цель:** Предоставить инструмент, который поможет пользователям более точно планировать
  свое время, путем предсказания времени выполнения задач на основе исторических данных. Это
  позволит ускорить процесс планирования и улучшит оценку сроков выполнения задач.

- **Необходимость использования ML:** Традиционные методы оценки времени выполнения задач требуют
  времени на анализ и оценку. ML-модель позволит автоматически анализировать исторические данные и
  выявлять зависимости. Это позволит пользователям быстрее и точнее планировать свою работу.

- **Критерии успеха итерации:**
    - **Точность предсказаний:** 1.2 (1) – Weighted Accuracy > 50% (Определение ниже)
    - **Положительная обратная связь:** Пользователи (я, мой руководитель) отмечают улучшение в
      планировании задач.

---

### 1.2 Бизнес-требования и ограничения

#### Бизнес-требования

1. Точность предсказаний. Weighted Accuracy > 50% – описание ниже.
2. Производительность. Время отклика модели не должно превышать 10 секунд на один запрос.
    - Почему 10? Мы хотим использовать модель во время планирования задач. Условно 10-15 задач
      берется на одного человека и для каждой нужно предсказать время выполнения. На планировании
      выделено на одного человека 30 минут. 10 секунд на задачу – это (15 * 10 / 30) / 30 ~ 8.5% =
      10% времени на планирование. Больше 10% времени на ожидание ответа от модели выглядит
      неудобно.
3. Безопасность. Защита данных пользователей и конфиденциальность информации.

#### Бизнес-ограничения

1. Необходимо начать использование модели уже в январе 2024 года.
2. Обеспечение конфиденциальности и соответствие требованиям GDPR.
3. Ограничения на мощности локальных машин и / или затрат на облачные вычисления.

---

### 1.3 Что входит в скоуп проекта/итерации, что не входит

#### Входит

- Предоставление прогнозов времени выполнения задач на основе исторических данных с аргументацией.
- Swagger и REST API для доступа к системе.
- Документация по использованию API и модели.

#### Не входит

- Веб-интерфейс для управления задачами.
- Управление приоритетами и дедлайнами.

---

### 1.4 Предпосылки решения

- **Наличие данных:** Исторические данные о задачах и времени их выполнения доступны для обучения
  модели.
- **Reasoning в современных моделях:** Использование LLM и других современных методов для анализа
  текста в предсказании времени выполнения задач. Модели могут учитывать контекст и сложные
  зависимости между задачами, аргументировать свои решения.

---

## 2. Методология

### 2.1 Постановка задачи

- **Тип задачи:** Регрессия.
- **Описание:** Предсказать время выполнения задачи на основе ее описания и других доступных
  характеристик (например, тип задачи, сложность, связанные задачи).

---

### 2.2 Блок-схема решения

```mermaid
flowchart LR
    step_0(
        <b> Этап 0 <br>
Сбор данных </b>

На основе истории задач пользователя
собираем данные для обучения

Фичи на основе текста задачи
Таргет - время выполнения
)

step_1_baseline(
<b> Этап 1 <br>
Baseline <br> </b>
Простая модель на TF-IDF и
Linear Regression
)

step_1_mvp(
<b> Этап 1 <br>
MVP модель <br> </b>
LLM + Embeddings + TF-IDF +
ER + Linear Regression

Построение модели для
предсказания времени выполнения
задачи, сравнение с baseline
)

step_2(
<b> Этап 2 <br>
Валидация модели <br> </b>
Оценка качества модели
на тестовой выборке и
валидация попадания в таргет

Метрики со штрафами за
недооценку времени выполнения
)

step_3(
<b> Этап 3 <br>
Тестирование модели <br> </b>
Использование модели в
реальном планировании для
предсказания времени выполнения
задач на ближайший спринт

Сбор обратной связи
)

step_4(
<b> Этап 4 <br>
AutoML пайплайн <br> </b>
Построение пайплайна для
обучения модели на новых данных

Автоматизация обучения для
возможности адаптироваться к
новым данным от пользователя
или обучиться на данных других
пользователей
)

step_5(
<b> Этап 5 <br>
Интерпретатор модели <br> </b>
Построение интерпретатора
для объяснения предсказаний
модели пользователю

Возможность увидеть, какие
слова и фразы влияют на
предсказание времени выполнения
)

step_6(
<b> Этап 6 <br>
Создание API и документирование <br> </b>
Создание REST API для
предсказания времени выполнения
задач

Документирование API
и инструкции по использованию
)

subgraph step 0
step_1_baseline
step_1_mvp
end

step_0 --> step_1_baseline
step_0 --> step_1_mvp
step_1_baseline --> step_2
step_1_mvp --> step_2
step_2 --> step_3
step_3 --> step_4
step_4 --> step_5
step_5 --> step_6

style step_0 fill: #dae8fc, stroke: #333, stroke-width: 1.5px
style step_1_baseline fill: #fce8da, stroke: #333, stroke-width: 1.5px
style step_1_mvp fill: #dafce8, stroke: #333, stroke-width: 1.5px
style step_2 fill: #dae8fc, stroke: #333, stroke-width: 1.5px
style step_3 fill: #dae8fc, stroke: #333, stroke-width: 1.5px
style step_4 fill: #dae8fc, stroke: #333, stroke-width: 1.5px
style step_5 fill: #dae8fc, stroke: #333, stroke-width: 1.5px
style step_6 fill: #dafce8, stroke: #333, stroke-width: 1.5px


```

### 2.3 Этапы решения задачи

**Этап 1: Сбор и подготовка данных**

- Сбор исторических данных о задачах.
- Сборка пайплайна для автоматической обработки данных из Jira и Slack.
- Предобработка данных: очистка, нормализация, токенизация текста.

Данные:

- Сырой текст треда из Slack, описывающий задачу.
- Описание задачи из Jira.
- Meeting notes, где упоминается задача и что необходимо сделать.

**Этап 2.1: Разработка базовой модели**

- Построение базовой модели с использованием TF-IDF и линейной регрессии.
- Оценка базовой точности предсказаний.

Выход модели должен состоять из оценки времени выполнения задачи и уровня уверенности в предсказании

```json
{
  "predicted_hours": 4,
  "confidence": 0.8
}
```

**Этап 2.2: Разработка MVP модели**

- Построение MVP модели с использованием LLM, Embeddings, TF-IDF, ER и линейной регрессии.
- Выбор оптимальной архитектуры модели.

На этом этапе модель должна учитывать контекст задачи, другие задачи пользователя, его специализацию
и другие факторы, влияющие на время выполнения задачи.

Выход модели должен содержать дополнительные фичи, учитывающие контекст задачи и пользователя

```json
{
  "predicted_hours": 4,
  "confidence": 0.8,
  "description": "Some task description",
  "features": {
    "task_complexity": "High",
    "user_specialization": "Data Science",
    "definition_of_done": "Code review",
    "stake_holders": [
      "Product Owner",
      "Team Lead"
    ]
  }
}
```

**Этап 3: Валидация модели**

- Оценка качества модели на тестовой выборке.
- Оценка точности предсказаний и попадания в таргет.
- Оценка метрик с учетом штрафов за недооценку времени выполнения.

Метрики:

- Доля недооцененных задач < 10%. `Estimated time < Real time.`
- Доля задач переоцененных более чем на 1 шаг стори поинта < 20%.
- Weighted Accuracy > 50%

**Этап 4: Тестирование модели**

- Использование модели в реальном планировании задач.
- Сбор обратной связи от пользователей. Проверка точности предсказаний метриками из этапа 4.
- Оценка эффективности модели в реальных условиях.

**Этап 5: Автоматизация и интерпретация**

- Построение AutoML пайплайна для обучения модели на новых данных.
- Создание REST API для доступа к модели.

Результаты модели должны быть доступны через REST API с возможностью получения предсказаний времени,
загрузки новых данных и дообучения модели.

**Этап 6: Интерпретация модели**

- Построение интерпретатора для объяснения предсказаний модели пользователю.
- Возможность увидеть, какие слова и фразы влияют на предсказание времени выполнения задач.

На этом этапе на выходе модели хочется видеть не только предсказание, но и объяснение, почему модель
сделала такое предсказание.

```json
{
  "predicted_hours": 4,
  "confidence": 0.8,
  "features": {
    "task_complexity": "High",
    "user_specialization": "Data Science",
    "definition_of_done": "Code review",
    "stake_holders": [
      "Product Owner",
      "Team Lead"
    ],
    "reasoning": {
      "task_complexity": "Due to some facts from tasks X, Y, Z and requirements A, B, C ..."
    }
  }
}
```

---

## 3. Подготовка пилота

### 3.1 Способ оценки пилота

- Метрики Критерии успеха. 
  - Метрика точности с учетом асимметрии ошибок. Нам менее важно переоценить
    время выполнения задачи, чем недооценить. Точность предсказаний Weighted Accuracy > 50%. (Текущая метрика с ручной оценкой ~ 33%)
  - Производительность: Время отклика API – Latency ≤ 10 секунд.
  - Надежность: 95% запросов обрабатываются без ошибок.

$$
\text{Weighted Accuracy} = 100\% \times \left( 1 - \frac{\sum_{i=1}^{N} W_i \cdot |T_{\text{pred}, i} - T_{\text{actual}, i}|}{\sum_{i=1}^{N} T_{\text{actual}, i}} \right)
$$

Где:

- $T_{\text{pred}, i}$ — предсказанное время выполнения задачи \( i \).
- $T_{\text{actual}, i}$ — фактическое время выполнения задачи \( i \).
- $W_i$ — вес ошибки:
  $$
  W_i =
  \begin{cases}
  \alpha, & \text{если } T_{\text{pred}, i} < T_{\text{actual}, i}, \\
  1, & \text{если } T_{\text{pred}, i} \geq T_{\text{actual}, i}.
  \end{cases}
  $$
- $alpha$ — коэффициент штрафа за недооценку времени (например, $alpha = 2$).
- $N$ — общее количество задач.


### 3.2 Успешность пилота

- Успешный пилот:
    - Достижение поставленных метрик.
    - Положительная обратная связь от тестовых пользователей.
    - Отсутствие критических ошибок в работе модели и API.

